import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import { rules } from "../lib";
import { repository } from "../package.json";
import type { TestCafeLint } from "../lib/globals";

const README_LOCATION = path.resolve(__dirname, "..", "README.md");
const BEGIN_TABLE_MARKER = "<!-- __BEGIN AUTOGENERATED RULES TABLE__ -->";
const END_TABLE_MARKER = "<!-- __END AUTOGENERATED RULES TABLE__ -->";

function generateTable(): string[] {
    const repoURL = repository.url.replace(/^git:\/\//, "");
    return (Object.keys(rules) as TestCafeLint.RuleName[]).sort().reduce(
        (lines, ruleId) => {
            const rule = rules[ruleId];

            const tr = [
                `[${ruleId}](https://${repoURL}/blob/master/docs/rules/${ruleId}.md)`,
                rule.meta.docs?.recommended ? "âœ”ï¸" : "",
                rule.meta.fixable ? "ðŸ› " : "",
                rule.meta.docs?.description || ""
            ].join(" | ");

            lines.push(`| ${tr} |`);

            return lines;
        },
        [
            "| Name  | âœ”ï¸     | ðŸ›      | Description |",
            "| ----- | ----- | ----- | ----------- |"
        ]
    );
}

function prettierFormatTable(tableRows: string[]): string[] {
    const tmpFile = path.resolve(
        path.dirname(README_LOCATION),
        path.basename(README_LOCATION).replace(/\.md$/, ".tmp.md")
    );
    // Add exit handler to delete temporary file
    process.addListener("exit", () => {
        fs.rmSync(tmpFile);
    });

    // Write to temporary file
    fs.writeFileSync(tmpFile, tableRows.join("\n"));

    // Run npm run format:file -- $TEMP_FILE
    try {
        execSync(`npm run format:file -- ${tmpFile}`);
    } catch (e) {
        const err = new Error("Failed to prettier format markdown table.");
        // err.stack += e.message
        throw err;
    }

    // Read back in new contents
    const lintedTableResult = fs.readFileSync(tmpFile, "utf-8");

    // Return file contents as array of lines, drop ending newline
    return lintedTableResult.split("\n").slice(0, -1);
}

function updateReadme(tableRows: string) {
    const readmeContents = fs.readFileSync(README_LOCATION, "utf8");

    if (!readmeContents.includes(BEGIN_TABLE_MARKER)) {
        throw new Error(
            `Could not find '${BEGIN_TABLE_MARKER}' marker in README.md.`
        );
    }

    if (!readmeContents.includes(END_TABLE_MARKER)) {
        throw new Error(
            `Could not find '${END_TABLE_MARKER}' marker in README.md.`
        );
    }

    let linesStartIndex = readmeContents.indexOf(BEGIN_TABLE_MARKER);
    const linesEndIndex = readmeContents.indexOf(END_TABLE_MARKER);
    linesStartIndex += BEGIN_TABLE_MARKER.length; // Offset start to not overwrite Table Marker

    const updatedReadmeContents = [
        readmeContents.slice(0, linesStartIndex),
        null, // newline spacing for prettier markdown linter
        tableRows,
        null, // newline spacing
        readmeContents.slice(linesEndIndex)
    ].join("\n");

    fs.writeFileSync(README_LOCATION, updatedReadmeContents);
}

function main(writeToDisk = true): string | undefined {
    let tableRows: string[] = [];
    tableRows = generateTable();
    tableRows = prettierFormatTable(tableRows);
    if (writeToDisk) {
        updateReadme(tableRows.join("\n"));
        return undefined;
    }
    return tableRows.join("\n");
}

/**
 * ON_SCRIPT_LOAD
 */
if (require.main === module) {
    // Run on command line
    main();
} else {
    module.exports = {
        main,
        get table() {
            return main(false);
        }
    };
}
